/** Задание для изучения языка JavaScript на примере создания текстовой игры.
 *  Текстовая, пошаговая игра на 2 игрока
 *  Игровое поле одномерное. Ходы игроки делают поочереди
 *  У игрока есть очки действий (AP), очки жизни (HP)
 *  У игрока есть следующие варианты действий:
 *    - сходить вперёд,
 *    - сходить назад,
 *    - атаковать,
 *    - закончить ход,
 *    - сдаться
 *  на каждое из этих действий (кроме закончить ход и сдаться) тратятся очки действий
 *  Каждый игрок, в начале игры выбирает оружие (меч, кинжалы, лук, может что-то ещё)
 *  У каждого оружия есть максимальная дистанция, например у меча это 2
 *  Чем больше дистанция до противника, тем меньший наноситься урон
 *  например меч на дистанции 1 снимает больше HP чем на дистанции 2
 *  Каждое оружие тратит определённое количество AP
 *  
 *    В дальнейшем можно расширить геймплей игры, например ввести новые действия
 *  добавить умения (перки), магию и манну, телепорт (ограниченный по количеству использований),
 *  лечилки, смена оружия и всё на что хватит фантазии.
 *  Так же можно будет сделать визуализацию, уже в браузере,
 *  сделать игровое поле не одномерным, а двумерным
 * 
 *  Сейчас ввод и вывод делаем прям в классе Game, т.е. пока идём неправильным путём.
 *  Исправимся, когда будем делать графику (в браузере).
 */


class Weapon {
  damage;
  actionPoints;

  // храним в статическом свойстве класса все варианты оружия
  // !!! посмотри что такое статические свойства и методы
  // тут для примера только меч (sword), цифры от болды, можно менять
  // остальное на тебе
  static Types = {
      sword: {
        // damage тут массив, потому что на каждой дистанции
        // урон будет разный. Не забудь, что индексация массива начинается с нуля
        // т.е. damage[0] вернёт 3, а damage[1] вернёт 2
        // лук сможет действовать на большую дистанцию. Т.е. количество элементов в массиве
        // будет больше
        damage: [ 3, 2 ],
        // количество AP которое вычтутся у игрока при использования этого оружия 
        actionPoints: 2,
      },
      // кинжалы
      daggers: {
        // TODO: заполни
      },
      // лук
      bow: {
        // TODO: заполни
      }
    };

  constructor(type) {
    this.damage = type.damage;
    this.actionPoints = type.actionPoints;
  }

  hit(distance) {
    return // тут должен вернуть damage, в зависимости от дистанции
  }
}


class Game {
  players; // тут в массиве два игрока
  currentPlayerIndex = 0; // индекс текущего игрока в массиве игроков

  setWeapon(player1, player2) {
    this.players = [player1, player2];
  }

  giveCurrentPlayer() { // получить текущего игрока
    return this.players[this.currentPlayerIndex];
  }

  // TODO: реализуй следующие методы
  next() { // ниже написал, что в этом методе нужно будет делать, в остальных думай сам
    // меняем текущего игрока
    // спрашиваем у него, что делать
    // делаем выбранное действие
  }
  anAction(action) {}
  start() {} // начать игру
  end() {} // конец игры, нужно будет вывести результат
  render() {} // вывод текущего игрового поля в консоль
  // TODO: добавь ещё методы, если нужны
}


/** Класс игровое поле
 *  хранит координаты игроков
 *  вычисляет, может ли сходить игрок по игровому полю
 *  меняет координаты игроков
 */
class PlayingField {
  field; // непосредственно само поле, в виде одномерного массива

  // при создании экземпляра в конструктор передаём размер игрового поле
  // т.е. если напишем new PlayingField(9), то создаст игровое поле из 9 ячеек
  constructor(size) {
    // создаём массив из [size] элементов и заполняем его
    // значениями null, т.е. все ячейки пустые, там никто не стоит
    this.field = Array(size).fill(null)
  }

  addPlayer(player, coord) {} // добавляет игрока на поле. Если успешно, возвращает true, иначе false
  canMove(player, shift) {} // возвращает true, если может сходить, иначе false
  move(player, shift) {
    if (this.canMove(player, shift)) {
      // тут меняем координату TODO: реализуй
      return true; // т.е. успешно сходили
    } else {
      console.log('Не могу туда сходить! Выбери другое действие.');
      return false; // не успешно сходили
    }
  }
}


class Player {
  name; // Имя игрока для отображения в виде строки
  weapon; // Экземпляр класса Weapon
  ap = 3; // очки действия, обновляется каждый ход
  hp = 15; // очки здоровья

  // варианты текстовых команд которые могут вводить игроки
  static Actions = [
    ['step-back', 'SB', 'шаг вперед', 'шаг вперёд'],
    ['step-forward', 'SF', 'шаг назад'],
    ['hit', 'H', 'удар'],
    ['end-move', 'EM', 'конец хода'],
    ['give-up', 'GU', 'сдаться'],
  ]

  constructor(name, weapon) {
    this.name = name;
    this.weapon = weapon;
  }

  // TODO: нужно реализовать эти методы
  stepBack() {} // шаг назад
  stepForward() {} // шаг вперёд
  hit() {} // воспользоваться оружием
  endMove() {} // закончить ход
  giveUp() {} // сдаться


  receivedDamage(damage) {} // игрок получил урон
  // TODO: добавь ещё методы, если нужны
}


async function init() {
  const SIZE_FIELD = 9; // размер игрового поля
  const P1_COORD = 4; // координата первого игрока
  const P2_COORD = 5; // координата второго игрока

  //
  const weapon1 = new Weapon();
  const weapon2 = new Weapon();
  const player1 = new Player(weapon1);
  const player2 = new Player(weapon2);
  const field = new PlayingField(SIZE_FIELD);
  field.addPlayer(player1, P1_COORD);
  field.addPlayer(player2, P2_COORD);
  const game = new Game(player1, player2, field);
  game.start();
}


init();
